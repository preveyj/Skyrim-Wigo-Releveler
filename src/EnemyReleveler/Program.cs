using EnemyReleveler.Enums;
using EnemyReleveler.LevelRanges;
using EnemyReleveler.Models;
using EnemyReleveler.Selectors;
using EnemyReleveler.Validators;
using Mutagen.Bethesda;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Synthesis;
using Noggog;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;

namespace EnemyReleveler
{
    public enum LevelType
    {
        MaxLevel,
        MinLevel,
        Level
    }

    public class Program
    {
        public static List<string> underleveledNpcs = new();
        public static List<string> overleveledNpcs = new();
        public static List<string> lowPoweredNpcs = new();
        public static List<string> highPoweredNpcs = new();

        private static Lazy<Settings> _Settings = null!;

        public static HashSet<IFormLinkGetter<INpcGetter>> npcsToIgnore = new()
        {
            Skyrim.Npc.MQ101Bear,
            Skyrim.Npc.WatchesTheRootsCorpse,
            Skyrim.Npc.BreyaCorpse,
            Skyrim.Npc.WatchesTheRoots,
            Skyrim.Npc.Drennen,
            Skyrim.Npc.Breya,
            Skyrim.Npc.dunHunterBear,
            Dawnguard.Npc.DLC1HowlSummonWerewolf,
        };

        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings("Settings", "settings.json", out _Settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "enemies_releveled.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            //check that Synthesis generated settings
            var settings = _Settings?.Value;
            if (settings == null)
                throw new Exception("Settings could not be found!");

            //get level ranges
            var selectedRange = _Settings?.Value.RangeChoices ?? RangeChoices.Default;            
            Dictionary<string, LevelRange> enemyRules = new LevelRangeSelector().GetLevelRangeBySelection(selectedRange).GetLevelRanges();
            var nullableCustomRangeFromSettings = _Settings?.Value.CustomLevelRanges;

            //if the user chooses Custom, we have to get the list from _Settings
            if (selectedRange == RangeChoices.Custom && nullableCustomRangeFromSettings != null)
            {
                enemyRules = nullableCustomRangeFromSettings;
            }

            //validate list
            var isListValid = new RangeValidator().ValidateList(enemyRules);
            if (!isListValid)
                throw new ArgumentException();

            if (settings.PrintDebugOutput)
            {
                Console.WriteLine("==================================================");
                Console.WriteLine($"Range selected: {_Settings?.Value.RangeChoices}");
                Console.WriteLine();
                foreach (var enemyRule in enemyRules)
                {
                    Console.WriteLine($"{enemyRule.Key}: {enemyRule.Value.MinLevel} - {enemyRule.Value.MaxLevel}");
                }
                Console.WriteLine("==================================================");
            }

            var vanillaRanges = new VanillaRanges().GetLevelRanges();

            foreach (var getter in state.LoadOrder.PriorityOrder.Npc().WinningOverrides())
            {
                //filter NPCs
                if (npcsToIgnore.Contains(getter)
                    || getter.Configuration.TemplateFlags.HasFlag(NpcConfiguration.TemplateFlag.Stats))
                {
                    continue;
                }

                bool skip = true;
                var faction = "";
                LevelRange newRange = new LevelRange();
                LevelRange vanillaRange = new LevelRange();

                //get the first faction for the NPC that exists both in the selected ranges and vanilla ranges
                foreach (var rank in getter.Factions)
                {
                    if (!rank.Faction.TryResolve(state.LinkCache, out var factionRecord)) continue;
                    faction = factionRecord.EditorID ?? "";
                    if (enemyRules.ContainsKey(faction) && vanillaRanges.ContainsKey(faction))
                    {
                        skip = false;
                        newRange = enemyRules[faction];
                        vanillaRange = vanillaRanges[faction];
                    }
                    if (skip == false) break;
                }

                if (skip) continue;

                //Start releveling
                var npc = getter.DeepCopy();
                if (npc.Configuration.Level is IPcLevelMult)
                {
                    EditValue(npc, LevelType.MinLevel, vanillaRange, newRange, settings, faction);
                    EditValue(npc, LevelType.MaxLevel, vanillaRange, newRange, settings, faction);
                }
                else
                {
                    EditValue(npc, LevelType.Level, vanillaRange, newRange, settings, faction);
                }

                state.PatchMod.Npcs.GetOrAddAsOverride(npc);
            }
            printWarnings();
        }

        public static void EditValue(INpc npc, LevelType levelType, LevelRange vanillaRange, LevelRange newRange, Settings settings, string faction)
        {
            decimal currentLevel = 1;
            switch (levelType)
            {
                case LevelType.MinLevel:
                    currentLevel = npc.Configuration.CalcMinLevel;
                    break;
                case LevelType.MaxLevel:
                    currentLevel = npc.Configuration.CalcMaxLevel;
                    if (currentLevel == 0) return;
                    break;
                case LevelType.Level:
                    if (npc.Configuration.Level is INpcLevelGetter level) currentLevel = level.Level;
                    //check for overpowered/underpowered NPCs
                    if (currentLevel < vanillaRange.MinLevel) underleveledNpcs.Add(npc.EditorID ?? "");
                    if (currentLevel > vanillaRange.MaxLevel) overleveledNpcs.Add(npc.EditorID ?? "");
                    break;
                default:
                    break;
            }

            double newLevel = // settings.UseZEditConfiguration?

                // zEdit patcher formula
                //Math.Round(((double)(currentLevel - rule[0][0]) / (rule[0][1] - rule[0][0])) * (rule[1][1] - rule[1][0]) + rule[1][0]) :

                // synthesis patcher formula
                //Math.Round(
                //    Math.Pow((double)
                //            (currentLevel - rule[0][0]) /   //currentLevel - vanilla minimum level
                //            (rule[0][1] - rule[0][0])       //vanilla max - vanilla minimum
                //        , 1.5
                //    ) * 
                //    (
                //        rule[1][1] - rule[1][0]
                //    ) + 
                //    rule[1][0]);

                //don't shrink the level?
                Math.Round(
                    Math.Pow(
                        ((double)(currentLevel - vanillaRange.MinLevel) / (vanillaRange.MaxLevel - vanillaRange.MinLevel))
                        , 1.5
                    )
                    * (newRange.MaxLevel - newRange.MinLevel)
                    + newRange.MinLevel
                );

            //prevent negative level NPCs and record more overpowered/underpowered NPCs
            if (newLevel < 1)
            {
                if (levelType == LevelType.Level) lowPoweredNpcs.Add(npc.EditorID ?? "");
                newLevel = 1;
            }

            var clampMaxLevel = _Settings?.Value.ClampMaxLevel ?? true;
            
            if (clampMaxLevel)
            {
                //clamp max level - somehow we were getting absurd numbers
                if (newLevel > newRange.MaxLevel)
                    newLevel = newRange.MaxLevel;

                newLevel += settings.GlobalOffset;
            }
            else
            {
                //why 100 for the max?
                if (newLevel > 100 & levelType == LevelType.Level) highPoweredNpcs.Add(npc.EditorID ?? "");
            }


            if (settings.PrintDebugOutput)
            {
                Console.WriteLine($"Calculated new {levelType} for {faction} member {npc.EditorID}: {newLevel}. Current {levelType}: {currentLevel}, current assumed min: {vanillaRange.MinLevel}, current assumed max: {vanillaRange.MaxLevel}, new min: {newRange.MinLevel}, new max: {newRange.MaxLevel}.");
            }
            
            switch (levelType)
            {
                case LevelType.MinLevel:
                    npc.Configuration.CalcMinLevel = (short)newLevel;
                    break;
                case LevelType.MaxLevel:
                    npc.Configuration.CalcMaxLevel = (short)newLevel;
                    break;
                case LevelType.Level:
                    npc.Configuration.Level = new NpcLevel()
                    {
                        Level = (short)newLevel
                    };
                    break;
                default:
                    break;
            }
        }

        public static void printWarnings()
        {
            if (underleveledNpcs.Count > 0)
            {
                Console.WriteLine("Warning, the following NPCs were at a lower level than the patcher expected (i.e. below the lower bound of the starting range). Its not a problem, and they have been patched, chances are another mod has changed their level too. This is just to let you know.");
                foreach (var item in underleveledNpcs)
                {
                    Console.WriteLine(item);
                }
            }
            if (overleveledNpcs.Count > 0)
            {
                Console.WriteLine("Warning, the following NPCs were at a higher level than the patcher expected (i.e. above the upper bound of the starting range). Its not a problem, and they have been patched, chances are another mod has changed their level too. This is just to let you know.");
                foreach (var item in overleveledNpcs)
                {
                    Console.WriteLine(item);
                }
            }
            if (lowPoweredNpcs.Count > 0)
            {
                Console.WriteLine("Warning, the faction rule told the patcher to give the following NPCs a level < 1. This has been ignored and the NPCs level has been set to 1.");
                foreach (var item in lowPoweredNpcs)
                {
                    Console.WriteLine(item);
                }
            }
            if (highPoweredNpcs.Count > 0)
            {
                Console.WriteLine("Warning, the faction rule told the patcher to give the following NPCs a level > 100. Good luck!");
                foreach (var item in highPoweredNpcs)
                {
                    Console.WriteLine(item);
                }
            }
        }
    }
}

